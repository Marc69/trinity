#! /usr/bin/env python
##title          : cv_install_moncon
##description    : Configures the monitoring server: adds hosts from the xCAT db and static (hardware groups).
##author         : Abhishek Mukherjee, Hans Then
##email          : abhishek.mukherjee@clustervision.com, hans.then@clustervision.com

import sys
import subprocess
import requests
import json

# For now hardcoding the files and IPs. 
default_xcat_host="10.141.255.254"
default_xcat_query={'userName':'trinity', 'password':'trinity', 'pretty':'1'}
default_monitoring='monitoring'
# HTH default_hosts_file="/opt/omd/sites/"+default_monitoring+"/etc/check_mk/conf.d/wato/hosts.mk"
# HTH default_aggr_file="/opt/omd/sites/"+default_monitoring+"/etc/check_mk/multisite.mk"

default_hosts_file="/cluster/omd/hosts.mk"
default_aggr_file="/cluster/omd/multisite.mk"

class MonCon(object):
  def __init__(self,xcat_host,xcat_query,monitoring,hosts_file,aggr_file): 
    self.xcat_host=xcat_host
    self.xcat_query=xcat_query
    self.monitoring=monitoring
    self.hosts_file=hosts_file
    self.aggr_file=aggr_file

  def get_hosts_from_xcat(self):
    node_list=requests.get("https://"+self.xcat_host+"/xcatws"+"/nodes", verify=False, params=self.xcat_query).json()
    print node_list
    def chunks(l, n):
        """Yield successive n-sized chunks from l."""
        for i in xrange(0, len(l), n):
            yield l[i:i+n]

    hosts_dict={}
    for chunk in chunks(node_list, 50):
        node_string=",".join(chunk)
        print node_string
        node_info=requests.get("https://"+self.xcat_host+"/xcatws"+"/nodes/"+node_string, verify=False, params=self.xcat_query).json()
        for node,node_dict in node_info.iteritems():
            try:
                host_ip=node_dict['ip']
                # Try hostname first, if not use node name
                try:
                    hostnames=node_dict['hostnames'].strip().split(',')
                    host_name=hostnames[0]
                except:
                    host_name=node
                hosts_dict.update({host_name : host_ip})
            except:
                print 'No IP address for node: '+node  
    return hosts_dict  

  def add_hosts(self,hosts_dict):
    for host_name,host_ip in hosts_dict.iteritems():
      self.add_host(host_name,host_ip)

  def add_rule(self,rule="ping",desc="PING",func="worst",check="PING"):
    aggr_rule='aggregation_rules[\"'+rule+'\"] = (\"'+desc+'\", [ "HOST" ], \"'+func+'\", [( \"$HOST$\", \"'+check+'\" ),])'
    fop=open(self.aggr_file,'a')
    fop.write("\n"+aggr_rule+"\n")
    fop.close()
    print aggr_rule
    print "AGGR_RULES: Added aggr_rule "+rule+" to check "+check+" and aggregate "+func
 
  def get_groups_from_xcat(self):
    group_list=requests.get("https://"+self.xcat_host+"/xcatws"+"/groups", verify=False, params=self.xcat_query).json()
    group_string=",".join(group_list)
    group_info=requests.get("https://"+self.xcat_host+"/xcatws"+"/groups/"+group_string, verify=False, params=self.xcat_query).json()
    groups_dict={}
    for group,group_dict in group_info.iteritems():
      members_string=group_dict['members'].strip()
      if members_string:
        members_list=members_string.split(",")
        groups_dict.update({group:members_list})
      else:
        groups_dict.update({group:[]})
    return groups_dict  

  # this should also work for static virtual clusters, but not for updating
  def add_hw_aggrs(self,groups_dict,hw='hw-'):
    for group,members in groups_dict.iteritems():
      if group.startswith(hw):
        len_hw=len(hw)
        aggr=group[len_hw:]
        self.add_aggr(aggr,members)



  ################################################################################################

  # AM : Apr 29, 2015
  # Removing IP addresses and host_attributes from hosts.
  # Hosts will be accesed by their hostnames
  # Adding IP addresses breaks for containers,
  # because their IP addresses change with the repartitioning

  def add_host(self,host_name,host_ip=None):
    host='all_hosts += [ \"'+host_name+'|cmk-agent|prod|lan|tcp|wato|/\" + FOLDER_PATH + \"/\", ]'
    fop=open(self.hosts_file,'a')
    fop.write('\n'+host+'\n')
    fop.close()
    print "ALL HOSTS: Added host "+host_name

  def add_aggr(self,aggr_name,aggr_members,check='ping'):
    for host_name in aggr_members:
      self.add_host_to_aggr(host_name,aggr_name,check)

  def add_host_to_aggr(self,host_name,aggr_name,check='ping'): 
    aggregation='aggregations += [( \"'+aggr_name+'\", \"'+check+'\", [\"'+host_name+'\"]),]'
    try:
        fop=open(self.aggr_file,'a')
        fop.write("\n"+aggregation+"\n")
        fop.close()
    except Exception, e:
        print e
    print aggregation
    print "AGGREGATIONS: Added "+host_name+" to "+aggr_name+" to check "+check
      
################################################################################################## 


def main(xcat_host,xcat_query,monitoring,hosts_file,aggr_file):
  
  mc=MonCon(xcat_host,xcat_query,monitoring,hosts_file,aggr_file)
  # Add hosts from the xCAT db
  hosts_dict=mc.get_hosts_from_xcat()
  mc.add_hosts(hosts_dict)
  #cmd='su - '+monitoring+' -c \"check_mk -R\"'
  cmd = 'docker exec -u monitoring omd bash -lc "check_mk -R"'
  subprocess.call(cmd,shell=True)  

  # For now only adding pingability 
  mc.add_rule(rule="ping",desc="PING",func="worst",check="PING")
  groups_dict=mc.get_groups_from_xcat()
  mc.add_hw_aggrs(groups_dict)


if __name__=='__main__':  
  main(default_xcat_host,default_xcat_query,default_monitoring,default_hosts_file,default_aggr_file)
  
